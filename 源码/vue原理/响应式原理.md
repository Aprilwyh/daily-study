
响应式原理：在改变数据的时候，视图会跟着更新。
## 1. 初始化 Vue 实例
## 2. 数据劫持（Proxy 见双向绑定篇）
Object.defineProperty 设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行**依赖收集**，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。
```js
class Observer {
    constructor(data) {
        this.observer(data)
    }
    // 观察者(监听对象的响应式)
    observer(obj) {
        // 判断是否为对象
        if (typeof obj !== 'object' || obj == null) return obj

        // 实时响应数组中对象的变化
        if (Array.isArray(obj)) {
            Object.setPrototypeOf(obj, proto) // 如果是数组，就设置重写的数组原型对象
            this.observerArray(obj) // 监听数组
        } else {
            // 遍历对象 key value 监听值的变化
            for (let key in obj) {
                this.defineReactive(obj, key, obj[key])
            }
        }
    }
    defineReactive(obj, key, value) {
        // value 可能是对象，需要进行递归
        this.observer(value) // 递归
        Object.defineProperty(obj, key, {
            get() {
                return value
            },
            set: newValue => {
                if (newValue !== value) {
                    // 传入的可能也是对象，需要递归
                    this.observer(value) // 递归
                    value = newValue
                    console.log('视图更新')
                }
            }
        })
    }
    // ---------------------------监听数组部分------------------------------
    // 遍历数组中的对象，并设置监听
    observerArray(obj) {
        for (let i = 0; i < obj.length; i++) {
            let item = obj[i];
            this.observer(item); // 如果数组中是对象会被 defineReactive 监听
        }
    }

    let arrProto = Array.prototype; // 数组原型上的方法
    let proto = Object.create(arrProto); // 复制原型上的方法
    // 重写数组的三个方法
    [`push`, `unshift`, `splice`].forEach(method => {
        proto[method] = function(...args) {
        // 这个数组传入的对象也应该进行监控
            let inserted; // 默认没有插入新的数据
            switch (method) {
                case `push`:
                case `unshift`:
                    inserted = args;
                    break;
                case `splice`:
                    inserted = args.slice(2); // 截出传入的数据
                    break;
                default:
                    break;
            }
            console.log("---------------视图更新-----------------");
            observerArray(inserted); // 如果数组增加的值是对象类型，需要对其设置监听
            arrProto[method].call(this, ...args);
        };
    })
}
```
   - 声明一个 Observer 类，接收传入 data 中要给页面渲染的数据。
   调用 this.observer(data) 方法，遍历 data 中的每个数据进，都通过 Object.defineProperty() 方法设置上监听。
   > 监听对象
   - observer() 方法实现主要用于实时响应数组中对象的变化。
   data 是一个对象，我们对 data 数据对象进行遍历，通过调用 defineReactive 方法，给每个属性分别设置监听（ set 和 get 方法）。
   我们对属性设置的监听，只是第一层设置了监听，如果属性值是个对象，我们也要进行监听。或者我们在给 Vue 实例 vm 中 data 赋值的时候，也可能是个对象，所以我们要进行递归，也给其设置响应式。
   - 设置好之后，当我们运行程序，给 vm 设置某一值的时候，会触发视图的更新。

   > 监听数组
   - 上述我们只对对象的属性进行监听，但是我们希望监听的是个数组，对于数组，用 Object.defineProperty() 来设置是不起作用的。如果数组中存放的是对象，我们也应该监听属性的变化
   - 首先，我们判断当前传入的如果是数组类型，我们就调用 observerArray 方法。
   - 当我们进行下方更改值时，视图被触发更新。
   `vm.$data.d[3].name = "11"; // 更改数组中的对象属性的值`
   `vm.$data.d.push({ age: "15" }); // 通过 push 向 data 中的数组中添加一个值`

## 3. 依赖收集
收集依赖的目的：知道哪些地方依赖我的数据，以及数据更新时派发更新。  
收集依赖的实现：核心思想就是“事件发布订阅模式”（订阅者 Dep和观察者 Watcher）
### 订阅者 Dep
收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep,它用来收集依赖、删除依赖和向依赖发送消息等。  
订阅者中主要通过 addSub 方法增加观察者，通过 notify 通知观察者，调用观察者的 update 进行更新相应的视图。
```js
class Dep {
    constructor() {
        this.subs = []; // 存放所有的 watcher
    }
    // 订阅
    addSub(watcher) {
        this.subs.push(watcher);
    }
    // 通知
    notify() {
        this.subs.forEach(watcher => watcher.update());
    }
}
```
当需要依赖收集的时候调用 addSub，当需要派发更新的时候调用 notify
```js
// 调用
let dp = new Dep()
dp.addSub(() => {
    console.log('emit here')
})
dp.notify()
```
### 观察者 Watcher
可以把Watcher理解成一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。



## 流程梳理
1. 初始化阶段：data的属性都加上 setter/getter 来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。
    Dep就是一个观察者类，每一个data的属性都会有一个dep对象。当getter调用的时候，去dep里注册函数
    setter的时候，就是去通知执行刚刚注册的函数。
2. mount 阶段：创建一个Watcher类的对象（每一个Watcher对应一个vue component）watcher连接vue组件与dep。

## 链
[详解响应式原理](https://www.cnblogs.com/fundebug/p/responsive-vue.html)  

[黄轶深入响应式原理](https://www.imooc.com/article/14466)  
[从源码解析vue响应式原理](https://segmentfault.com/a/1190000012612657)  
[知乎-简化的vue响应式原理](https://zhuanlan.zhihu.com/p/88648401)  

