### 写在前面
简洁而清晰的概念  
闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。  
在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 "new Function" 语法 中讲到）。
```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // ???
foo()(); // ???
```
> 2; 2
上面两种调用方式是一样的。而且这就是闭包。
foo()执行后通常整个内部作用域都被销毁，引擎有垃圾回收器来释放不再使用的内存空间。而闭包可以阻止这样的事情发生，使作用域一直存活，在之后任何时间进行引用，这个引用就叫做闭包。  
闭包的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。
### 两个例子
对函数类型的值进行传递
```js
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  bar(baz);
}
function bar(fn) {
  fn(); // 能够访问foo()内部的a，这就是闭包
}
foo();
```
间接传递函数
```js
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz;
}
function bar() {
  fn(); // 这就是闭包
}
foo();
bar();
```
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
### 内存机制
JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。  
闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。