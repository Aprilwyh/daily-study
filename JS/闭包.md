### 写在前面
简洁而清晰的概念  
闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。  
在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 "new Function" 语法 中讲到）。
```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // ???
foo()(); // ???
```
> 2; 2
上面两种调用方式是一样的。而且这就是闭包。
foo()执行后通常整个内部作用域都被销毁，引擎有垃圾回收器来释放不再使用的内存空间。而闭包可以阻止这样的事情发生，使作用域一直存活，在之后任何时间进行引用，这个引用就叫做闭包。  
闭包的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。
### 判断闭包
对函数类型的值进行传递
```js
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  bar(baz);
}
function bar(fn) {
  fn(); // 能够访问foo()内部的a，这就是闭包
}
foo();
```
间接传递函数
```js
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz;
}
function bar() {
  fn(); // 这就是闭包
}
foo();
bar();
```
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
常见的例子如下：
```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
wait("Hello");
```
只要使用了回调函数，实际上就是在使用闭包。
### 循环和闭包
```js
for (var i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i*1000);
}
```
> 或许预期是分别输出1~5，每秒一次，每次一个。  
但实际这段代码会以每秒一次的频率输出五次6。  
- 循环终止的条件是i>5,首次成立时i的值是6.输出显示循环结束时i的最终值。
- 延迟函数的回调会在循环结束时才执行。因此每秒输出一个6。
```js
for(var i=1; i<=5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j*1000);
  })(i);
}
```
这样的代码才是我们预期的代码。原因是因为
- 之前的例子
   - 循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，实际上只有一个i
   - 所以我们需要更多的闭包作用域，循环的过程中每个迭代都需要一个闭包作用域。
- 改进后的例子
   - IIFE拥有了自己的变量，用来在每个迭代中储存i的值
   - 在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都有一个具有正确值的变量供我们访问。
### 块作用域
上面改进后的例子利用IIFE创建独立的作用域保存变量i的值。  
ES6中引入了块作用域的概念（let），所以我们可以将上面的改进更一步优化
```js
for(let i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i*1000);
}
```
### 内存机制
JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。  
闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。