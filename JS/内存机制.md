### 写在前面
栈、堆、队列的形象比喻  
- 栈：乒乓球盒。后进先出（基本类型） 
- 堆：书架。随意拿取（引用类型）
- 队列：管道。先进先出
### 内存空间
JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。  
闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数执行之后为什么闭包还能引用到函数内的变量。
#### 内存空间管理
JS的内存生命周期
- 分配所需要的内存
- 使用分配到的内存（读和写）
- 不需要时将其释放、归还
### 内存回收
JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。
- 局部变量和全局变量的销毁
   - 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
   - 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。
- 以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的
   - 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
   - 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
- V8引擎对堆内存中的JS对象进行分代管理
   - 新生代：存活周期较短的JS对象，如临时变量、字符串等。
   - 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。
### 垃圾回收算法
核心思想就是如何判断内存已经不再使用。常用垃圾回收算法有下面两种。
#### 引用计数（现代浏览器不再使用）
判断标准：看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。  
引用计数有一个致命的问题，那就是循环引用。  
如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。
```js
var div = document.createElement("div");
div.onclick = function() {
    console.log("click");
};
```
这就是一个循环引用。  
变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。
#### 标记清除（常用）
判断标准：从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。**可达性**  

### 内存泄漏
对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）轻则影响系统性能，重则导致进程崩溃  
最常见的内存泄露一般都与DOM元素绑定有关
```js
email.message = document.createElement(“div”);
displayList.appendChild(email.message);

// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
```
div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中 
#### 内存泄漏识别方法？
[内存泄漏识别方法](https://muyiy.cn/blog/1/1.4.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95)  
#### 内存泄露如何避免？
四种常见的JS内存泄漏
- 意外的全局变量
- 被遗忘的计时器或回调函数
- 脱离 DOM 的引用
- 闭包
[内存泄露如何避免](https://muyiy.cn/blog/1/1.5.html#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)  
在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。
### 其他
ES6 新出的两种数据结构：WeakSet 和 WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。