<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    function Person() { }
    Person.prototype.name = 'Tom'
    Person.prototype.age = 29
    Person.prototype.sayName = function () {
      alert(this.name + '来自原型')
    }
    var person1 = new Person()
    var person2 = new Person()
    // alert(Person.prototype.isPrototypeOf(person1)) // true 有指向关系
    // alert(Object.getPrototypeOf(person1).name) // Tom 来自原型

    person1.name = 'Jerry'
    // alert(person1.hasOwnProperty('name')) // true 来自实例
    // alert(person1.name + '来自实例对象1') // Jerry来自实例对象1
    // alert(person2.name + '来自实例对象2') // Tom来自实例对象2
    delete person1.name
    // alert(person1.name + '来自实例对象1') // Tom来自实例对象1

    // alert(person1.hasOwnProperty('name')) // false 不是实例对象的属性就返回false
    // alert("name" in person1) // true 能够访问到name属性就返回true

    // 确定是不是原型中的属性（in操作符返回true 且 hasOwnProperty()方法返回false）
    function hasPrototypeProperty(obj, name) {
      return (name in obj) && !obj.hasOwnProperty(name)
    }
    // alert(hasPrototypeProperty(person1, 'name')) // true 是来自原型
    person1.name = 'Lily'
    // alert(hasPrototypeProperty(person1, 'name')) // false 不来自原型

    // 获取实例属性
    // Object.keys()，仅列出可枚举的
    // Object.getOwnPropertyNames()，列出所有包括constructor

    // 设置原型对象的constructor Object.defineProperty()

    // 组合使用构造函数模式和原型模式
    function Person1(name, age) {
      this.name = name
      this.age = age
      this.friends = ["Tom", "Jerry"]
    }
    Person1.prototype = {
      constructor: "Person1",
      sayName: function () {
        alert(this.name)
      }
    }
    var person3 = new Person1("xiaoming", 20)
    var person4 = new Person1("hong", 18)
    person3.friends.push("Nan")
    alert(person3.friends) // "Tom", "Jerry", "Nan"
    alert(person4.friends) // "Tom", "Jerry"
    // person3.friends === person4.friends;person3.sayName !== person4.sayName

    // 动态原型模式
    function Person2(name, age) {
      this.name = name
      this.age = age
      if (typeof this.sayName != "function") {
        Person2.prototype.sayName = function () {
          alert(this.name)
        }
      }
    }
    var friend = new Person2("Bai", 17)
    friend.sayName()
    // 使用动态原型模式时，不能使用对象字面量重写原型

    // 寄生构造函数模式
    function PersonJi(name, age) { // 除了这里是包装函数外，其他和工厂模式一模一样
      var o = new Object()
      o.name = name
      o.age = age
      o.sayName = function () {
        alert(this.name)
      }
      return o
    }
    var friendJi = new PersonJi("Hei", 22)
    friendJi.sayName() // Hei
    function SpecialArray() {
      var arr = new Array()
      arr.push.apply(arr, arguments)
      arr.toPipedString = function () {
        return this.join("|")
      }
      return arr
    }
    var colors = new SpecialArray("red", "pink", "blue")
    alert(colors.toPipedString()) // red|pink|blue
  </script>
</body>

</html>