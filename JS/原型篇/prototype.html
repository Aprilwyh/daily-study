<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    // 组合使用构造函数模式和原型模式
    function Person1(name, age) {
      this.name = name
      this.age = age
      this.friends = ["Tom", "Jerry"]
    }
    Person1.prototype = {
      constructor: "Person1",
      sayName: function () {
        // alert(this.name)
      }
    }
    var person3 = new Person1("xiaoming", 20)
    var person4 = new Person1("hong", 18)
    person3.friends.push("Nan")
    // alert(person3.friends) // "Tom", "Jerry", "Nan"
    // alert(person4.friends) // "Tom", "Jerry"
    // person3.friends === person4.friends;person3.sayName !== person4.sayName

    // 动态原型模式
    function Person2(name, age) {
      this.name = name
      this.age = age
      if (typeof this.sayName != "function") {
        Person2.prototype.sayName = function () {
          // alert(this.name)
        }
      }
    }
    var friend = new Person2("Bai", 17)
    friend.sayName()
    // 使用动态原型模式时，不能使用对象字面量重写原型

    // 寄生构造函数模式
    function PersonJi(name, age) { // 除了这里是包装函数外，其他和工厂模式一模一样
      var o = new Object()
      o.name = name
      o.age = age
      o.sayName = function () {
        // alert(this.name)
      }
      return o
    }
    var friendJi = new PersonJi("Hei", 22)
    friendJi.sayName() // Hei
    function SpecialArray() {
      var arr = new Array()
      arr.push.apply(arr, arguments)
      arr.toPipedString = function () {
        return this.join("|")
      }
      return arr
    }
    var colors = new SpecialArray("red", "pink", "blue")
    // alert(colors.toPipedString()) // red|pink|blue

    let animal = {
      eats: true,
      walk() {
        if (!this.isSleeping) {
          alert(`I walk`);
        }
      },
      sleep() {
        this.isSleeping = true;
      }
    }
    let rabbit = {
      jumps: true,
      name: "White Rabbit",
      __proto__: animal
    }
    rabbit.walk = function () {
      alert("Rabbit! Bounce-bounce!");
    };
    // rabbit.__proto__ = animal
    // rabbit.walk() // animal walk
    // rabbit.sleep(); // rabbit.isSleeping: true,animal.isSleeping: undefined（原型中没有此属性）
    // animal.sleep(); // rabbit.isSleeping: true,animal.isSleeping: true
    // alert(rabbit.isSleeping);
    // alert(animal.isSleeping);

    let user = {
      name: 'Tom',
      surname: 'Smith',
      set fullName(value) { // value = "Alice Cooper"
        [this.name, this.surname] = value.split(" ")
        // this不受原型影响，始终是点符号 . 前面的对象。
        // setter 调用 admin.fullName= 使用 admin 作为 this，而不是 user
        // 当继承的对象运行继承的方法时，它们将仅修改自己的状态，而不会修改大对象的状态。
      },
      get fullName() {
        return `${this.name} ${this.surname}`
      }
    }
    let admin = {
      __proto__: user,
      isAdmin: true
    }
    // alert(admin.fullName) // Tom Smith ,从get中拿到的
    // alert(user.fullName) // Tom Smith
    admin.fullName = "Alice Cooper"
    // alert(admin.fullName) // Alice Cooper ，重新set的
    // alert(user.fullName) // Tom Smith

    // ===============================================================================




  </script>
</body>

</html>