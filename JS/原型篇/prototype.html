<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    function Person() { }
    Person.prototype.name = 'Tom'
    Person.prototype.age = 29
    Person.prototype.sayName = function () {
      alert(this.name + '来自原型')
    }
    var person1 = new Person()
    var person2 = new Person()
    // alert(Person.prototype.isPrototypeOf(person1)) // true 有指向关系
    // alert(Object.getPrototypeOf(person1).name) // Tom 来自原型

    person1.name = 'Jerry'
    // alert(person1.hasOwnProperty('name')) // true 来自实例
    // alert(person1.name + '来自实例对象1') // Jerry来自实例对象1
    // alert(person2.name + '来自实例对象2') // Tom来自实例对象2
    delete person1.name
    // alert(person1.name + '来自实例对象1') // Tom来自实例对象1

    // alert(person1.hasOwnProperty('name')) // false 不是实例对象的属性就返回false
    // alert("name" in person1) // true 能够访问到name属性就返回true

    // 确定是不是原型中的属性（in操作符返回true 且 hasOwnProperty()方法返回false）
    function hasPrototypeProperty(obj, name) {
      return (name in obj) && !obj.hasOwnProperty(name)
    }
    // alert(hasPrototypeProperty(person1, 'name')) // true 是来自原型
    person1.name = 'Lily'
    // alert(hasPrototypeProperty(person1, 'name')) // false 不来自原型

    // 获取实例属性
    // Object.keys()，仅列出可枚举的
    // Object.getOwnPropertyNames()，列出所有包括constructor

    // 设置原型对象的constructor Object.defineProperty()

    // 组合使用构造函数模式和原型模式
    function Person1(name, age) {
      this.name = name
      this.age = age
      this.friends = ["Tom", "Jerry"]
    }
    Person1.prototype = {
      constructor: "Person1",
      sayName: function () {
        // alert(this.name)
      }
    }
    var person3 = new Person1("xiaoming", 20)
    var person4 = new Person1("hong", 18)
    person3.friends.push("Nan")
    // alert(person3.friends) // "Tom", "Jerry", "Nan"
    // alert(person4.friends) // "Tom", "Jerry"
    // person3.friends === person4.friends;person3.sayName !== person4.sayName

    // 动态原型模式
    function Person2(name, age) {
      this.name = name
      this.age = age
      if (typeof this.sayName != "function") {
        Person2.prototype.sayName = function () {
          // alert(this.name)
        }
      }
    }
    var friend = new Person2("Bai", 17)
    friend.sayName()
    // 使用动态原型模式时，不能使用对象字面量重写原型

    // 寄生构造函数模式
    function PersonJi(name, age) { // 除了这里是包装函数外，其他和工厂模式一模一样
      var o = new Object()
      o.name = name
      o.age = age
      o.sayName = function () {
        // alert(this.name)
      }
      return o
    }
    var friendJi = new PersonJi("Hei", 22)
    friendJi.sayName() // Hei
    function SpecialArray() {
      var arr = new Array()
      arr.push.apply(arr, arguments)
      arr.toPipedString = function () {
        return this.join("|")
      }
      return arr
    }
    var colors = new SpecialArray("red", "pink", "blue")
    // alert(colors.toPipedString()) // red|pink|blue

    let animal = {
      eats: true,
      walk() {
        if (!this.isSleeping) {
          alert(`I walk`);
        }
      },
      sleep() {
        this.isSleeping = true;
      }
    }
    let rabbit = {
      jumps: true,
      name: "White Rabbit",
      __proto__: animal
    }
    rabbit.walk = function () {
      alert("Rabbit! Bounce-bounce!");
    };
    // rabbit.__proto__ = animal
    // rabbit.walk() // animal walk
    // rabbit.sleep(); // rabbit.isSleeping: true,animal.isSleeping: undefined（原型中没有此属性）
    // animal.sleep(); // rabbit.isSleeping: true,animal.isSleeping: true
    // alert(rabbit.isSleeping);
    // alert(animal.isSleeping);

    // alert(Object.keys(rabbit)) // jumps,name,walk
    // for (let prop in rabbit) alert(prop) // jumps name walk eats sleep
    // for..in 循环也会迭代继承的属性。
    // 想排除继承的属性，有一个内建方法 obj.hasOwnProperty(key)
    for (let prop in rabbit) {
      let own = rabbit.hasOwnProperty(prop)
      if (own) {
        // alert(`our:${prop}`) // jumps,name,walk
      } else {
        // alert(prop) // eats sleep
      }
    }

    let user = {
      name: 'Tom',
      surname: 'Smith',
      set fullName(value) { // value = "Alice Cooper"
        [this.name, this.surname] = value.split(" ")
        // this不受原型影响，始终是点符号 . 前面的对象。
        // setter 调用 admin.fullName= 使用 admin 作为 this，而不是 user
        // 当继承的对象运行继承的方法时，它们将仅修改自己的状态，而不会修改大对象的状态。
      },
      get fullName() {
        return `${this.name} ${this.surname}`
      }
    }
    let admin = {
      __proto__: user,
      isAdmin: true
    }
    // alert(admin.fullName) // Tom Smith ,从get中拿到的
    // alert(user.fullName) // Tom Smith
    admin.fullName = "Alice Cooper"
    // alert(admin.fullName) // Alice Cooper ，重新set的
    // alert(user.fullName) // Tom Smith

    // ===============================================================================
    let father = {
      handsome: true
    }
    function Children(name) {
      this.name = name
    }
    alert(Children.prototype.constructor == Children) // true

    Children.prototype = father
    let children1 = new Children("xiaoming") // children1.__proto__ == father
    alert(children1.handsome) // true
    let children2 = new children1.constructor("xiaohong");
    alert(children1.constructor === children2.constructor)
    // alert(children1.constructor === Children) // false

    let hamster = {
      stomach: [],
      eat(food) {
        // 分配给 this.stomach 而不是 this.stomach.push
        this.stomach = [food]; // apple <nothing>
        // this.stomach.push(food) // apple apple

        // this.stomach= 不会执行对 stomach 的查找。该值会被直接写入 this 对象
        // this.stomach.push() 需要找到 stomach 属性，然后对其调用 push，
        // 于是顺着原型链向上查找拿到了hamster的stomach属性
      }
    };
    let speedy = {
      __proto__: hamster
    };
    let lazy = {
      __proto__: hamster
    };
    // 仓鼠 Speedy 找到了食物
    speedy.eat("apple");
    alert(speedy.stomach); // apple
    // 仓鼠 Lazy 的胃是空的
    alert(lazy.stomach); // <nothing>

  </script>
</body>

</html>