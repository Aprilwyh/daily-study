什么是原型？
原型能做什么？
原型的原理是什么？

每个函数都有一个 prototype （原型）内置属性，这个属性是一个指针指向一个（原型）对象。

prototype是通过调用构造函数而创建的那个对象实例的原型对象。

使用原型对象的好处：可以让所有对象实例共享它包含的属性和方法。
缺点：
- 所有实例在默认情况下都取得相同的属性值
- 因为共享导致了一个实例修改了包含引用类型值的属性（相当于直接修改了原型对象），影响其他实例


创建新函数 -> 为该函数创建一个prototype属性 -> 该属性向函数的原型对象
所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在的函数

实例中的指针仅指向原型，而不指向构造函数
在已经创建了实例的情况下重写原型会切断现有实例与新原型之间的联系

寄生构造函数模式
> 工厂模式没有办法确定类型
> 构造函数模式不能创建实例对象并返回
返回的对象与构造函数/构造函数的原型属性之间没有关系，不能依赖instanceof操作符来确定对象类型

稳妥构造函数模式
instanceof操作符对这种对象也没有意义

***
### \[[Prototype]]
对象的内置属性，是对其他对象（原型）的引用
无法在对象本身找到需要的属性，就访问对象的\[[Prototype]]链，直到找到属性或者查找完整条原型链
\[[Prototype]]的尽头：最终会指向Object.prototype，再向上是null
属性 \[[Prototype]] 是内部的而且是隐藏的，设置它的方式
- 使用特殊的名字 \_\_proto__
> \_\_proto__ 与 \[[Prototype]] 不一样，\_\_proto__ 是 \[[Prototype]] 的因历史原因而留下来的 getter/setter
> Object.getPrototypeOf/Object.setPrototypeOf 也能 get/set 原型

引用不能形成闭环
\_\_proto__的值可以是对象，也可以是null

### prototype
每个函数都有 "prototype" 属性，即使我们没有提供它。
默认的 "prototype" 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。

### constructor

### 原型中的this
来看下面的例子
```javascript
let user = {
    name: 'Tom',
    surname: 'Smith',
    set fullName(value) {
        [this.name, this.surname] = value.split(" ") // this是admin，不是user
    },
    get fullName() {
        return `${this.name} ${this.surname}`
    }
}
let admin = {
    __proto__: user,
    isAdmin: true
}
alert(admin.fullName) // Tom Smith
alert(user.fullName) // Tom Smith
admin.fullName = "Alice Cooper"
alert(admin.fullName) // Alice Cooper
alert(user.fullName) // Tom Smith
```
this不受原型影响，始终是点符号 . 前面的对象。(谁调用的方法，谁就是this)
setter 调用 admin.fullName= 使用 admin 作为 this，而不是 user
所以admin将仅修改自己的状态，而不会修改user的状态。

### 原型中的for...in循环
for..in 循环会迭代继承的属性。
想排除继承的属性，有一个内建方法 obj.hasOwnProperty(key) // 返回true或false
```javascript
alert(Object.keys(rabbit)) // jumps,name,walk 只返回自己的key
for (let prop in rabbit) alert(prop) // jumps name walk eats sleep 返回所有的key，包括继承来的
// 想排除继承的属性，还有一个内建方法 obj.hasOwnProperty(key)
for (let prop in rabbit) {
    let own = rabbit.hasOwnProperty(prop)
    if (own) {
        alert(`our:${prop}`) // jumps,name,walk
    } else {
        alert(prop) // eats sleep 继承来的
    }
}
```
rabbit.hasOwnProperty()来自Object，继承而来，但是for...in循环不出来。因为它是不可枚举的
同样Object.prototype的其他属性也不会被循环出来

性能的角度来看，我们是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。一旦有内容更改，它们就会自动更新内部缓存

