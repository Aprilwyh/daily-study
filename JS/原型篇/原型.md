### \[[Prototype]]
属性 \[[Prototype]] 是内部的而且是隐藏的，设置它的方式
- 使用特殊的名字 \_\_proto__
> \_\_proto__ 与 \[[Prototype]] 不一样，\_\_proto__ 是 \[[Prototype]] 的因历史原因而留下来的 getter/setter
> Object.getPrototypeOf/Object.setPrototypeOf 也能 get/set 原型

验证原型
```javascript
let arr = [1, 2, 3];
alert( arr.__proto__ === Array.prototype ); // ???
alert( arr.__proto__.__proto__ === Object.prototype ); // ???
alert( arr.__proto__.__proto__.__proto__ ); // ???
alert(Object.prototype.__proto__); // ???
```
> true true null null
arr继承自 Array.prototype
接下来继承自 Object.prototype
原型链的顶端为 null

### prototype
```javascript
function Rabbit() {}
// by default:
// Rabbit.prototype = { constructor: Rabbit }
```
> 每个函数都有 "prototype" 属性，即使我们没有提供它。

```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
Rabbit.prototype = {};
alert( rabbit.eats ); // ???
```
> true
Rabbit.prototype 的赋值操作为新对象设置了 \[\[Prototype]]，但它不影响已有的对象。
### constructor
```javascript
function Rabbit() {}
alert( Rabbit.prototype.constructor == Rabbit ); // ???
let rabbit = new Rabbit(); // inherits from {constructor: Rabbit}
alert(rabbit.constructor == Rabbit); // ???
```
> true
默认的 "prototype" 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。
> true
如果我们什么都不做，constructor 属性可以通过 \[\[Prototype]] 给所有 rabbits 使用

```javascript
function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};
let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // ???
```
> false
将整个默认 prototype 替换掉，那么其中就不会有 "constructor" 了

```javascript
function User(name) {
  this.name = name;
}
let user = new User('John');
let user2 = new user.constructor('Pete');
alert( user2.name ); // ???
```
> Pete
我们不触碰默认的 "prototype","constructor" 属性具有正确的值 User.prototype.constructor == User

```javascript
function User(name) {
  this.name = name;
}
User.prototype = {};
let user = new User('John');
let user2 = new user.constructor('Pete');
alert( user2.name ); // ???
```
> undefined
let user2 = new Object('Pete'),内建的 Object 构造函数会忽略参数

如何保证正确的constructor？
> 方法一
// 不要将 Rabbit.prototype 整个覆盖
// 可以向其中添加内容
Rabbit.prototype.jumps = true
// 默认的 Rabbit.prototype.constructor 被保留了下来

> 方法二
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};
手动重新创建 constructor 属性

> 方法三 TODO
<font color="red">Object.defineProperty</font>(Rabbit)
设置原型对象的constructor






> 红宝书中写到 “如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性”

这样一定会发生屏蔽吗？
1. \[[Prototype]]链上层存在同名普通数据访问属性并且没有被标记为只读（writable: false）。**会屏蔽**，同名属性也是屏蔽属性
2. \[[Prototype]]链上层存在同名属性但是被标记为只读，那么无法修改已有属性或创建屏蔽属性，严格模式下会报错否则会忽略这条语句。**不会屏蔽**
3. \[[Prototype]]链上层存在同名属性并且是一个setter，一定会调用这个setter，这个setter不会被重新定义。**不会屏蔽**
### 原型中的this
```javascript
let user = {
    name: 'Tom',
    surname: 'Smith',
    set fullName(value) {
        [this.name, this.surname] = value.split(" ") // this是admin，不是user
    },
    get fullName() {
        return `${this.name} ${this.surname}`
    }
}
let admin = {
    __proto__: user,
    isAdmin: true
}
alert(admin.fullName) // Tom Smith
alert(user.fullName) // Tom Smith
admin.fullName = "Alice Cooper"
alert(admin.fullName) // Alice Cooper
alert(user.fullName) // Tom Smith
```
> this不受原型影响，始终是点符号 . 前面的对象。(谁调用的方法，谁就是this)
setter 调用 admin.fullName= 使用 admin 作为 this，而不是 user
所以admin将仅修改自己的状态，而不会修改user的状态。
```javascript
    let hamster = {
      stomach: [],
      eat(food) {
        this.stomach.push(food); // *
      }
    };
    let speedy = {
      __proto__: hamster
    };
    let lazy = {
      __proto__: hamster
    };
    speedy.eat("apple");
    alert(speedy.stomach);
    alert(lazy.stomach);
```
> apple apple
this.stomach.push() 需要找到 stomach 属性，然后对其调用 push，于是顺着原型链向上查找拿到了hamster的stomach属性

```javascript
    let hamster = {
      stomach: [],
      eat(food) {
        this.stomach = [food]; // *
      }
    };
    let speedy = {
      __proto__: hamster
    };
    let lazy = {
      __proto__: hamster
    };
    speedy.eat("apple");
    alert(speedy.stomach);
    alert(lazy.stomach);
```
> alert \<nothing\>
this.stomach= 不会执行对 stomach 的查找。该值会被直接写入 this 对象


### 获取实例属性
```javascript
alert(Object.keys(rabbit)) // jumps,name,walk
```
> Object.keys()，仅列出可枚举的、自己的key

```javascript
for (let prop in rabbit) alert(prop) // jumps name walk eats sleep 
```
> for..in 循环会迭代继承的属性。(返回所有的key，包括继承来的)

```javascript
for (let prop in rabbit) {
    let own = rabbit.hasOwnProperty(prop)
    if (own) {
        alert(`our:${prop}`) // jumps,name,walk
    } else {
        alert(prop) // eats sleep 继承来的
    }
}
```
> 内建方法obj.hasOwnProperty(key)排除继承的属性
rabbit.hasOwnProperty()来自Object，继承而来,不可枚举
同样Object.prototype的其他属性也不会被循环出来

```javascript

```
> Object.getOwnPropertyNames()，列出所有包括constructor

### 判断属性来源
```javascript
function Person() { }
    Person.prototype.name = 'Tom'
    Person.prototype.age = 29
    Person.prototype.sayName = function () {
      alert(this.name + '来自原型')
    }
    var person1 = new Person()
    var person2 = new Person()
    alert(Person.prototype.isPrototypeOf(person1)) // ???
```
> true
isPrototypeOf()判断有无指向关系

```javascript
alert(Object.getPrototypeOf(person1).name) // ???
```
> Tom
Object.getPrototypeOf()

```javascript
alert(person1.hasOwnProperty('name'));
```
> true
Object.hasOwnProperty('属性名')

```javascript
alert("name" in person1);
```
> true
in操作符能够访问到name属性就返回true

写一个函数确定一个属性是不是原型中的属性
```javascript
function hasPrototypeProperty(obj, name) {
      return (name in obj) && !obj.hasOwnProperty(name)
    }
```
> in操作符返回true 且 hasOwnProperty()方法返回false

### 其他
delete运算符
delete person1.name
person1中删掉了name属性，从原型链中向上查找

性能的角度来看，我们是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。一旦有内容更改，它们就会自动更新内部缓存

