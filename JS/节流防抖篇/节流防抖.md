### 写在前面
在前端开发中会遇到一些频繁的事件触发，比如：
- window 的 resize、scroll
- mousedown、mousemove
- keyup、keydown
- ……
事件如何频繁的触发？  
【见 debounce.html 文件】  
解决这个问题，一般有两种方案：
- debounce 防抖
- throttle 节流

### 防抖
原理：当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。  
根据以上，编写代码  
```js
// 第一版
function debounce(func, wait) {
    var timeout;
    return function () {
        clearTimeout(timeout);
        timeout = setTimeout(func, wait);
    }
}
container.onmousemove = debounce(getCount, 1000);
```
现在不管怎么移动，移动完1000ms内不再触发，事件才会执行。继续完善此方法
#### this
在getCount函数中输出this，  
在不使用 debounce 函数的时候，this 的值为<div id="container"></div>，  
但是使用 debounce 函数的时候，this 指向window。  
修复this指向
```js
// 第二版
function debounce2(func, wait) {
    var timeout;
    return function () {
        var context = this;
        clearTimeout(timeout);
        timeout = setTimeout(function () {
            func.apply(context);
        }, wait);
    }
}
container.onmousemove = debounce2(getCount, 1000);
```
#### event对象
JavaScript 在事件处理函数中会提供事件对象 event  
不使用 debouce 函数的时候，打印 event 对象得到 MouseEvent 对象，  
使用 debounce 函数的时候，打印 event 对象得到 undefined。  
修复event对象
```js
function debounce3(func, wait) {
    var timeout;
    return function () {
        var context = this;
        var args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function () {
            func.apply(context, args);
        }, wait);
    }
}
container.onmousemove = debounce3(getCount, 1000);
```
#### 前缘debounce
上述例子均为**延迟debounce**，即设定周期，执行动作。  
而前缘debounce是执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定。  
即不用等到事件停止触发后才执行，而是立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。  
添加 immediate 参数，用来判断是否是立刻执行 （true立即执行; false非立即执行）
```js
function debounce4(func, wait, immediate) {
    var timeout;
    return function () {
        var context = this;
        var args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null;
            }, wait);
            if (callNow) func.apply(context, args);
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args);
            }, wait);
        }
    }
}
container.onmousemove = debounce4(getCount, 1000, true);
```
#### 返回值
之前的 getCount 函数是没有返回值的，但是它可能是有返回值的，所以也要返回函数的执行结果。  
**在 getCount 函数有返回值的情况下**，当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。
```js
function debounce5(func, wait, immediate) {
    var timeout, result;
    return function () {
        var context = this;
        var args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) result = func.apply(context, args)
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args)
                // result = func.apply(context, args); // result始终为undefined
            }, wait);
        }
        return result;
    }
}
container.onmousemove = debounce5(getCount, 1000, false);
```
#### 手动取消
假设 debounce 的时间间隔是 5 秒钟，immediate 为 true，这样的话，只有等 5 秒后才能重新触发事件。但是我希望可以手动点击取消防抖，此刻再次触发就又可以立刻执行了。（每次点击相当于一次重置）
```js
function debounce6(func, wait, immediate) {
    var timeout, result;
    var debounced = function () {
        var context = this;
        var args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null;
            }, wait);
            if (callNow) result = func.apply(context, args);
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args);
            }, wait);
        }
        return result;
    };
    debounced.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
    };
    return debounced;
}
```
使用自定义的cancel方法
```js
var setCount = debounce6(getCount, 5000, true);
container.onmousemove = setCount;
document.getElementById("button").addEventListener('click', function () {
    setCount.cancel();
})
```
### 节流