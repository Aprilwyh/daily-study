### 写在前面
在学习作用域前先了解下执行上下文（执行环境）和执行上下文栈相关概念  
[面试官：说说执行上下文吧](https://juejin.im/post/5ebced85e51d454dc1467664)

### 作用域
作用域指程序源代码中定义这个变量的区域。  
作用域 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 
【原理，理解性】  
#### 全局作用域和局部作用域
- 全局变量拥有全局作用域。
- 局部变量（函数内声明的变量、函数参数）作用域是局部性的。
#### 词法作用域（静态作用域）和动态作用域
JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。  
函数的作用域在函数定义的时候就决定了（基于函数创建的位置）。  
```js
var value = 1;
function foo() {
    console.log(value);
}
function bar() {
    var value = 2;
    foo();
}
bar(); // ???
```
> 1   
分析执行过程：  
- 执行foo函数，foo函数内部查找局部变量value。
   - 有。打印
   - 没有。根据书写位置查找上一层代码，这里是value为1

如果是动态作用域，那么执行过程是：  
- 执行foo函数，foo函数内部查找局部变量value。
   - 有。打印
   - 没有。从调用函数的作用域（即bar函数）内部查找value，这里是value为2
#### 函数作用域和块作用域
函数作用域指属于这个函数的全部变量都可以在整个函数的范围内使用及复用。  
```js
var a = 2;
function foo() { // <--
  var a = 3;
  console.log(a);
} // <--
foo(); // <--
console.log(a);
```
> 这种函数作用域并不理想，首先必须声明一个具名函数foo()，（foo污染了所在作用域）  
其次必须显式通过函数名foo()调用这个函数才能运行其中代码。  
如果函数不需要函数名且能够自动运行将会更加理想，即
```js
var a = 2;
(function foo() { // <--
  var a = 3;
  console.log(a);
})(); // <--
console.log(a);
```
> foo函数会被当作函数表达式而不是一个标准函数声明

前两个代码片段第一个片段中foo被绑定在所在作用域中，直接通过foo()来调用它。  
第二个片段中foo被绑定在函数表达式自身的函数中而不是所在作用域。  
- 函数声明和函数表达式最重要的区别就是他们的名称标识符会被绑定在何处。
- 函数声明和函数表达式的区分方法是看function关键字出现在声明中的位置。如果function是声明中第一个词就是函数声明，否则就是一个函数表达式（比如(function...）。
**IIFE 立即执行函数表达式**

下面讲解块级作用域
```js
for(var i=0; i<10; i++) {
  console.log(i);
}
```
i会被绑定在外部作用域（函数或全局）

let关键字可以将变量绑定到所在的任意作用域中（为其声明的变量隐式地劫持了所在的块级作用域）

#### 隐式作用域和显式作用域
用let将变量附加在一个已经存在的块级作用域上的行为是隐式的。

### 作用域嵌套
引擎从当前执行作用域开始查找变量。找不到，向上一级继续查找。抵达最外层全局作用域查找过程就停止。
```js
var scope = "global";
function checkscope() {
  var scope = "local";
  return scope;
}
checkscope()
console.log(scope) // ???
```
> "global"
使用var声明同名的全局变量与局部变量，局部变量优先级高于全局变量，前者会遮盖后者，但不会直接修改后者。

```js
scope = "global";
function checkscope() {
  scope = "local";
  return scope;
}
checkscope()
console.log(scope) // ???
```
> "local"
不使用var声明同名的全局变量与局部变量，局部变量会直接修改全局变量。

每个函数都有自己的作用域，函数定义是可以嵌套的，因此会出现几个局部作用域嵌套的情况。
```js
var scope = "global";
function checkscope() {
  var scope = "local";
  function nested() {
    var scope = "nested";
    return scope;
  }
  return nested();
}
checkscope() // ???
```
> "nested"
全局作用域 -> checkscope()局部作用域 -> nested()局部作用域（返回当前作用域内的值）

### 函数作用域和声明提前
js中没有块级作用域，取而代之使用了函数作用域。
```js
function test(o) {
  var i = 0;
  if (typeof o == "object") {
    var j = 0;
    for(var k=0; k < 10; k++) {
       console.log(k); // ???
    }
    console.log(k); // ???
  }
  console.log(j); // ???
}
```
> 0~9; 10; 0;
不同位置定义的变量i、j、k，但它们都在同一个作用域内，js的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明前已经可用，这个特性也被称为**声明提前**。


### 词法环境
在 JavaScript 中，每个运行的函数，代码块 {...} 以及整个脚本，都有一个被称为 词法环境（Lexical Environment） 的内部（隐藏）的关联对象。  
词法环境对象由两部分组成：
- 环境记录：一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。
- 对 外部词法环境 的引用，与外部代码相关联。
> 全局词法环境没有外部引用（null）。
#### 变量
- 变量是环境记录这个特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。
- 操作变量实际上是操作环境记录的属性。
#### 函数声明
一个函数其实也是一个值，就像变量一样。  
不同之处在于函数声明的初始化会被立即完成。（不像 let 那样直到声明处才可用）。  
以上针对于函数声明，而不适用函数表达式。
#### 内部和外部的词法环境
在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。  
当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。  
如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。  
#### 返回函数
所有的函数在“诞生”时都会记住创建它们的词法环境。所有函数都有名为 \[\[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。  
JavaScript 中的函数会自动通过隐藏的 \[\[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。

### 闭包
闭包 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。  
在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 "new Function" 语法 中讲到）。  
也就是说：JavaScript 中的函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。