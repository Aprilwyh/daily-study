### 函数表达式和函数声明
- 函数声明和函数表达式的区分方法是看function关键字出现在声明中的位置。如果function是声明中第一个词就是函数声明，否则就是一个函数表达式（比如(function...）。
- 函数声明和函数表达式最重要的区别就是他们的名称标识符会被绑定在何处。
- 函数表达式可以是匿名的，函数声明不可以省略函数名。
- 函数声明会发生提升，函数表达式不会。

### ReferenceError和TypeError
- ReferenceError同作用域判别失败相关
   - var a; LHS查询，找不到值会给个undefined（非严格模式）
   - a; RHS查询，如果没被定义就使用则会报错ReferenceError
- TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的（比如引用null或undefined的值中的属性）。
   - var foo; foo(); LHS查询，找不到值会给个undefined（非严格模式）但是undefined不能调用，所以报错TypeError

### call、apply和bind
apply、call、bind 都是可以改变 this 的指向的，区别是：
- 使用apply、call的函数直接执行
   - call和apply其实是同一个东西，区别只有参数不同
      - call(this, 参数1, 参数2...)
      - apply(this, [参数1, 参数2...])或者apply(this, arguments)
   - 传入call的参数只能是单个参数，不能是数组。apply可传入数组
- 使用bind需要手动调用才会执行

### 作用域链和原型链查找时的区别
- 如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回undefined。
- 查找的属性在作用域链中不存在的话就会抛出ReferenceError。

### instanceof和typeof的区别
- typeof判断所有变量的类型，返回值有number，boolean，string，function，object，undefined。
- typeof对于丰富的对象实例，只能返回"Object"字符串。
- instanceof用来判断对象，代码形式为obj1 instanceof obj2（obj1是否是obj2的实例），obj2必须为对象，否则会报错！其返回值为布尔值。
- instanceof可以对不同的对象实例进行判断，判断方法是根据对象的原型链依次向下查询，如果obj2的原型属性存在obj1的原型链上，（obj1 instanceof obj2）值为true。

### null和undefined
值类型的“虚无”，用 undefined。引用类型的“虚无”，用 null
| | 类型 | 数字型转换 | 初始值 | 何时使用 |
| - | - | - | - | - |
| null | object | 0 | null | 引用为空时（如对象）|
| undefined | undefined | NaN | undefined | 数值为空时（如普通变量）|

### Array.from(obj) 和 [...obj]
- Array.from 适用于类数组对象也适用于可迭代对象。（更通用）
- Spread 语法（后者）只适用于可迭代对象。