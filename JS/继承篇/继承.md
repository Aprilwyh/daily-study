### 写在前面
原型上的方法和属性被**继承**到新对象中，并不是被复制到新对象
### 1.原型链继承
原型链继承的本质是重写原型对象，代之以一个新类型的实例。
```js
function Parent () {
    this.name = 'kevin';
}
Parent.prototype.getName = function () {
    console.log(this.name);
}
function Child () {}
Child.prototype = new Parent();

var child1 = new Child();
console.log(child1.getName()) // kevin
```
新原型 Child 不仅有 new Parent() 实例上的全部属性和方法，并且由于指向了 Parent 原型，所以还继承了 Parent 原型上的属性和方法。
#### 缺点
1. 多个实例对引用类型的操作会被篡改
> 原型属性上的引用类型值会被所有实例共享，所以多个实例对引用类型的操作会被篡改。
2. 子类型的原型上的 constructor 属性被重写了
> 
3. 给子类型原型添加属性和方法必须在替换原型之后
4. 创建子类型实例时无法向父类型的构造函数传参
### 2.借用构造函数(经典继承)

### 3.组合继承

### 4.原型式继承

### 5.寄生式继承

### 6.寄生组合式继承

### 7.混入方式继承多个对象

### 8.ES6类继承extends